Игра Шашки 

Core файл 

Address.cs
using System;
using System.Drawing;

namespace Checkers
{
    /// <summary>
    /// Адрес ячейки
    /// </summary>
    [Serializable]
    public struct Address
    {
        const string chars = "abcdefgh";

        public char Column { get; set; }
        public int Row { get; set; }

        public Address(int x = -1, int y = -1)
        {
            if (x >= 0 && x < 8 && y >= 0 && y < 8)
            {
                Row = 7 - y + 1;
                Column = chars.ToCharArray()[x];
            }
            else
            {
                Column = '\0';
                Row = 0;
            }
        }

        public Address(string addr)
        {
            int row;
            if (!string.IsNullOrWhiteSpace(addr) && addr.Length == 2 && 
                chars.IndexOf(addr[0]) >= 0 && int.TryParse(addr[1].ToString(), out row) &&
                row > 0 && row <= 8)
            {
                Column = addr[0];
                Row = row;
            }
            else
            {
                Column = '\0';
                Row = 0;
            }
        }

        public bool IsEmpty()
        {
            return Column == '\0' && Row == 0;
        }

        public Point Coords
        {
            get { return new Point(chars.IndexOf(Column), 7 - (Row - 1)); }
        }

        public override string ToString()
        {
            return IsEmpty() ? "empty" : string.Format("{0}{1}", Column, Row);
        }
    }
}

Board.cs
using System;
using System.Collections;
using System.Collections.Generic;

namespace Checkers
{
    /// <summary>
    /// Результат хода
    /// </summary>
    public enum MoveResult
    {
        Prohibited,                 // запрещено
        SuccessfullMove,            // разрешённый простой ход
        SuccessfullCombat           // разрешённое взятие шашки противника
    }

    public enum GoalDirection
    {
        NW,
        N,
        NE,
        E,
        SE,
        S,
        SW,
        W
    }

    [Serializable]
    public class Board
    {
        const int _boardSize = 8;
        private readonly Hashtable _fields = new Hashtable();
        private Hashtable _cells = new Hashtable();
        private Cell _selected;

        private int _movedCount = 0;
        List<Cell> _steps = new List<Cell>();
        List<Cell> _battles = new List<Cell>();
        Game _game;

        public Board(Game game)
        {
            _game = game;
        }

        /// <summary>
        /// Привязка объекта game к доске
        /// </summary>
        /// <param name="game"></param>
        public void SetGame(Game game)
        {
            _game = game;
            var n = _game.Log.Count - 1;
            if (n < 0) return;
            var map = _game.Log[n].GetLastMap().DeepClone();
            SetMap(map);
        }

        public int SideSize { get { return _boardSize; } }

        /// <summary>
        /// Построение доски вначале
        /// </summary>
        public void ResetMap()
        {
            var whiteCheckers = "a1,c1,e1,g1,b2,d2,f2,h2,a3,c3,e3,g3";
            var blackCheckers = "b6,d6,f6,h6,a7,c7,e7,g7,b8,d8,f8,h8";
            _cells.Clear();
            _fields.Clear();
            _game.Direction = false;
            Selected = null;
            var black = false;  // признак чередования цветов полей
            for (var i = 0; i < _boardSize; i++)
            {
                State state;
                for (var j = 0; j < _boardSize; j++)
                {
                    var address = new Address(j, i);
                    if (whiteCheckers.Contains(address.ToString()))
                        state = State.White;
                    else if (blackCheckers.Contains(address.ToString()))
                        state = State.Black;
                    else
                        state = black ? State.Empty : State.Prohibited;
                    var cell = new Cell() { Address = address, State = state };
                    _cells[address] = cell;
                    _fields[address] = black ? State.Black : State.White;
                    black = !black; // чередуем цвет в столбце
                }
                black = !black;     // чередуем цвет в строке
            }
        }

        /// <summary>
        /// Положение фишек на доске в текстовую строку
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            var list = new List<string>();
            foreach (var item in _cells.Values)
            {
                var cell = (Cell)item;
                switch (cell.State)
                {
                    case State.Black:
                        list.Add(string.Format("{0}{1}", cell.King ? "B":"b", cell.Address));
                        break;
                    case State.White:
                        list.Add(string.Format("{0}{1}", cell.King ? "W" : "w", cell.Address));
                        break;
                }
            }
            return string.Join(",", list);
        }

        /// <summary>
        /// Установка фишек на доску из текстовой строки
        /// </summary>
        /// <param name="text"></param>
        public void SetMap(string text)
        {
            // очистка доски
            foreach (var item in _cells.Values)
            {
                var cell = (Cell)item;
                if (cell.State == State.Prohibited) continue;
                cell.King = false;
                cell.State = State.Empty;
            }
            // расстановка полученных фигур
            foreach (var value in text.Split(new[] { ',' }))
            {
                if (value.Length != 3) continue;
                var address = new Address(value.Substring(1));
                var cell = (Cell)_cells[address];
                switch (value[0])
                {
                    case 'b':
                        cell.State = State.Black;
                        break;
                    case 'B':
                        cell.State = State.Black;
                        cell.King = true;
                        break;
                    case 'w':
                        cell.State = State.White;
                        break;
                    case 'W':
                        cell.State = State.White;
                        cell.King = true;
                        break;
                }
            }
        }

        public Hashtable GetMap()
        {
            return _cells;
        }

        /// <summary>
        /// Установка фишек на доску из хеш-таблицы
        /// </summary>
        /// <param name="value"></param>
        public void SetMap(object value)
        {
            _cells = (Hashtable)value; 
        }

        /// <summary>
        /// Получить таблицу полей доски
        /// </summary>
        /// <returns></returns>
        public Hashtable GetFields()
        {
            return _fields;
        }

        /// <summary>
        /// Текущая ячейка
        /// </summary>
        public Cell Selected
        {
            get { return _selected; }
            set
            {
                _steps.Clear();
                _battles.Clear();
                _selected = value;
                if (_selected != null)
                    FillGoalCells(_selected);
            }
        }

        /// <summary>
        /// При текущем направлении игры проверяем, если у стороны "бьющие" фишки
        /// </summary>
        /// <returns></returns>
        public bool HasAnyCombat()
        {
            var result = false;
            foreach (var item in _cells)
            {
                var cell = (Cell)((DictionaryEntry)item).Value;
                var cellState = cell.State;
                var cellAddress = cell.Address;
                if (cellState == State.Empty || cellState == State.Prohibited) continue;
                if ((_game.Direction && cellState == State.Black ||
                    !_game.Direction && cellState == State.White) && HasCombat(cellAddress))
                    return true;
            }
            return result;
        }

        /// <summary>
        /// Фишка на этой позиции может произвести "бой"
        /// </summary>
        /// <param name="pos"></param>
        /// <returns></returns>
        public bool HasCombat(Address pos)
        {
            var result = false;
            if (pos.IsEmpty()) return result;
            var cell = (Cell)_cells[pos];
            // запрет хода для фишек не в свою очередь
            if (_game.Direction && cell.State != State.Black ||
                !_game.Direction && cell.State != State.White) return result;
            return HasGoals(cell, true);
        }

        /// <summary>
        /// Проверка возможности "хода" фишки
        /// </summary>
        /// <param name="startPos">Начальная позиция</param>
        /// <param name="endPos">Конечная позиция</param>
        /// <param name="direction">Направление проверки: false - фишки идут вверх, true - фишки идут вниз</param>
        /// <returns>Результат хода</returns>
        public MoveResult CheckMove(Address startPos, Address endPos, bool? king = null)
        {
            var result = MoveResult.Prohibited;
            if (startPos.IsEmpty() || endPos.IsEmpty()) return result;

            var startCellState = ((Cell)_cells[startPos]).State;
            if (startCellState != State.Empty)
            {
                // запрет хода для фишек не в свою очередь
                if (_game.Direction && startCellState != State.Black ||
                    !_game.Direction && startCellState != State.White) return result;
            }
            var dX = endPos.Coords.X - startPos.Coords.X;
            var dY = endPos.Coords.Y - startPos.Coords.Y;

            var startCellIsKing = king != null ? (bool)king : ((Cell)_cells[startPos]).King;
            var targetCellState = ((Cell)_cells[endPos]).State;
            if (targetCellState == State.Empty)
            {
                // проверка "боя"
                if (Math.Abs(dX) == 2 && Math.Abs(dY) == 2)
                {
                    // поиск "промежуточной" ячейки
                    var victimPos = new Address((startPos.Coords.X + endPos.Coords.X) / 2,
                                                (startPos.Coords.Y + endPos.Coords.Y) / 2);
                    var victimCellState = ((Cell)_cells[victimPos]).State;
                    // снимаем только фишку противника
                    result = targetCellState != victimCellState && startCellState != victimCellState
                                ? MoveResult.SuccessfullCombat : result;
                }
                else
                // проверка "хода"
                if (Math.Abs(dX) == 1 && dY == 1 && _game.Direction || 
                        Math.Abs(dX) == 1 && dY == -1 && !_game.Direction ||
                        // дамка "ходит" во все стороны
                        Math.Abs(dX) == 1 && Math.Abs(dY) == 1 && startCellIsKing)
                        result = MoveResult.SuccessfullMove;
            }
            return result;
        }

        /// <summary>
        /// Делаем "ход"
        /// </summary>
        /// <param name="startPos">Начальная позиция</param>
        /// <param name="endPos">Конечная позиция</param>
        /// <returns>результат хода</returns>
        public MoveResult MakeMove(Address startPos, Address endPos)
        {
            var moveResult = _steps.Contains((Cell)_cells[endPos]) ? MoveResult.SuccessfullMove : MoveResult.Prohibited;
            if (moveResult == MoveResult.SuccessfullMove)
            {
                if (!HasCombat(startPos))
                    Move(startPos, endPos);
                else
                {
                    OnShowError("Обязан рубить фишку противника", "Правило");
                    return MoveResult.Prohibited; // обязан брать шашку противника
                }
            }
            else
            {
                moveResult = _battles.Contains((Cell)_cells[endPos]) ? MoveResult.SuccessfullCombat : MoveResult.Prohibited;
                if (moveResult == MoveResult.SuccessfullCombat)
                {
                    Move(startPos, endPos);
                    // снятие фишек противника
                    var dx = Math.Sign(endPos.Coords.X - startPos.Coords.X);
                    var dy = Math.Sign(endPos.Coords.Y - startPos.Coords.Y);
                    var address = startPos;
                    while (true)
                    {
                        address = new Address(address.Coords.X + dx, address.Coords.Y + dy);
                        if (address.IsEmpty() || address.Coords == endPos.Coords) break;
                        Remove(address);
                    }
                }
            }
            return moveResult;
        }

        public event Action UpdateStatus = delegate { };

        private void OnUpdateStatus()
        {
            UpdateStatus();
        }

        public event Action<string, string> ShowError = delegate { };

        private void OnShowError(string message, string caption)
        {
            ShowError(message, caption);
        }

        public event Func<string, string, bool> AskQuestion = delegate { return false; };

        private bool OnAskQuestion(string message, string caption)
        {
            return AskQuestion(message, caption);
        }

        /// <summary>
        /// Переносим фишку на доске (вспомогательный метод)
        /// </summary>
        /// <param name="startPos">Начальная позиция</param>
        /// <param name="endPos">Конечная позиция</param>
        private void Move(Address startPos, Address endPos)
        {
            var startCell = (Cell)_cells[startPos];
            var endCell = (Cell)_cells[endPos];
            endCell.State = startCell.State;
            endCell.King = startCell.King;
            Remove(startPos);
        }

        /// <summary>
        /// Убираем фишку с доски (вспомогательный метод)
        /// </summary>
        /// <param name="pos">Позиция фишки</param>
        private void Remove(Address pos)
        {
            var cell = (Cell)_cells[pos];
            cell.State = State.Empty;
            cell.King = false;
        }

        /// <summary>
        /// Получение ячейки по адресу, с защитой от пустого адреса
        /// </summary>
        /// <param name="address"></param>
        /// <param name="cell"></param>
        /// <returns></returns>
        public bool GetCell(Address address, out Cell cell)
        {
            cell = null;
            if (address.IsEmpty()) return false;
            cell = (Cell)_cells[address];
            return cell != null;
        }

        /// <summary>
        /// Список ячеек, куда можно сделать ход
        /// </summary>
        /// <returns></returns>
        public List<Cell> GetSteps()
        {
            return _steps;
        }

        /// <summary>
        /// Список ячеек, куда можно сделать удар
        /// </summary>
        /// <returns></returns>
        public List<Cell> GetBattles()
        {
            return _battles;
        }

        public event Action<bool, Address, Address, MoveResult, int> CheckerMoved = delegate { };

        /// <summary>
        /// Обработка события перемещения фишки
        /// </summary>
        /// <param name="direction">Текущее направление игры: false - ходят белые</param>
        /// <param name="startPos">Начальное положение</param>
        /// <param name="endPos">Конечное положение</param>
        /// <param name="moveResult">Результат хода</param>
        private void OnCheckerMoved(bool direction, Address startPos, Address endPos, MoveResult moveResult, int stepCount)
        {
            CheckerMoved(direction, startPos, endPos, moveResult, stepCount);
        }

        public event Action ActivePlayerChanged = delegate { };

        private void OnActivePlayerChanged()
        {
            ActivePlayerChanged();
        }

        /// <summary>
        /// Выбираем фишку для начала хода
        /// </summary>
        /// <param name="location"></param>
        public void SelectSourceCell(Address location)
        {
            if (_game.WinPlayer != WinPlayer.Game) return;
            Cell cell;
            if (GetCell(location, out cell) && cell.State != State.Prohibited)
            {
                if (_game.Mode == PlayMode.Game || _game.Mode == PlayMode.NetGame)
                {
                    if (_game.Player == Player.Black && !_game.Direction ||
                        _game.Player == Player.White && _game.Direction) return;
                }
                // если ячейка не пустая, но не может быть выбрана
                if (cell.State != State.Empty && !CanCellEnter(cell))
                    return;
                // не должно быть выбранной ячейки с фишкой
                if (Selected == null)
                    // можем выбирать фишки только цвета игрока
                    SetSelectedCell(cell);
            }
        }

        /// <summary>
        /// Выбор целевой ячейки для хода или боя
        /// </summary>
        /// <param name="location"></param>
        public void SelectTargetCell(Address location)
        {
            if (_game.WinPlayer != WinPlayer.Game) return;
            Cell cell;
            if (GetCell(location, out cell) && cell.State != State.Prohibited)
            {
                if (_game.Mode == PlayMode.Game || _game.Mode == PlayMode.NetGame)
                {
                    if (_game.Player == Player.Black && !_game.Direction ||
                   _game.Player == Player.White && _game.Direction) return;
                }
                if (Selected != null && cell.State == State.Empty) // ранее была выбрана фишка и выбрана пустая клетка
                // пробуем делать ход
                {
                    var startPos = Selected.Address;
                    var endPos = cell.Address;
                    var moveResult = MakeMove(startPos, endPos);
                    Selected = null;  // после хода сбрасываем текущую выбранную фишку
                    if (moveResult != MoveResult.Prohibited)
                    {
                        // подсчёт очков
                        if (moveResult == MoveResult.SuccessfullCombat)
                        {
                            if (_game.Direction)
                                _game.BlackScore++;
                            else
                                _game.WhiteScore++;
                        }
                        _game.CheckWin();
                        // считаем количество непрерывных ходов одной стороной
                        _movedCount++;
                        // определение дамки
                        if (!cell.King &&
                            (!_game.Direction && cell.Address.Row == SideSize ||
                             _game.Direction && cell.Address.Row == 1)) cell.King = true;
                        var hasCombat = HasCombat(endPos); // есть ли в этой позиции возможность боя
                        // запоминаем очередь хода перед возможной сменой
                        var lastDirection = _game.Direction;
                        // или был бой и далее нет возможности боя
                        if (moveResult == MoveResult.SuccessfullCombat && !hasCombat ||
                            moveResult == MoveResult.SuccessfullMove)
                        {
                            // сообщаем о перемещении фишки
                            OnCheckerMoved(lastDirection, startPos, endPos, moveResult, _movedCount);
                            // сбрасываем количество непрерывных ходов одной стороной
                            _movedCount = 0;
                            // передача очерёдности хода
                            _game.Direction = !_game.Direction;
                            OnActivePlayerChanged();
                            _game.CheckWin();
                            if (_game.WinPlayer == WinPlayer.None)
                                CheckAvailableGoals();
                            return;
                        }
                        else if (moveResult == MoveResult.SuccessfullCombat && hasCombat)
                            // выбрана фишка для продолжения боя
                            SetSelectedCell(cell);
                        // сообщаем о перемещении фишки
                        OnCheckerMoved(lastDirection, startPos, endPos, moveResult, _movedCount);
                    }
                }
            }
        }

        private bool CheckAvailableGoals()
        {
            var player = _game.Player;
            foreach (var item in _cells.Values)
            {
                var cell = (Cell)item;
                if (player == Player.White && cell.State == State.White ||
                    player == Player.Black && cell.State == State.Black)
                {
                    if (HasGoals(cell)) return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Выбираем только "игровые" клетки, по которым фишки двигаются
        /// </summary>
        /// <param name="cell">Выбранная ячейка</param>
        private void SetSelectedCell(Cell cell)
        {
            if (cell.State == State.Black || cell.State == State.White)
            {
                Selected = cell;
            }
        }

        /// <summary>
        /// Проверка возможности выбрать указанную ячейку для начала "хода"
        /// </summary>
        /// <param name="cell">Целевая ячейка</param>
        /// <returns>true - выбор возможен</returns>
        public bool CanCellEnter(Cell cell)
        {
            // пустую ячейку сделать текущей не можем
            if (cell.State == State.Empty) return false;
            // "ходят" чёрные и пытаемся выбрать белую фишку
            // "ходят" белые и пытаемся выбрать чёрную фишку
            if (_game.Direction && cell.State == State.White ||
                !_game.Direction && cell.State == State.Black) return false;
            // у фишки нет ходов
            if (!HasGoals(cell)) return false;
            // если по очереди некоторые фишки могут "ударить", но эта фишка "ударить" не может
            if (HasAnyCombat() && !HasCombat(cell.Address))  return false;
            OnUpdateStatus();
            return true;
        }

        /// <summary>
        /// Есть ли у фишки вообще ходы?
        /// </summary>
        /// <param name="cell"></param>
        /// <returns></returns>
        private bool HasGoals(Cell cell, bool combat = false)
        {
            var steps = new List<Cell>();
            var battles = new List<Cell>();
            FillGoalCells(cell, steps, battles);
            var result = combat 
                ? battles.Count > 0 
                : steps.Count > 0 || battles.Count > 0;
            return result;
        }

        /// <summary>
        /// Заполнение списка ячеек, куда возможно перемещение фишки, с учетом правил
        /// </summary>
        /// <param name="selectedCell">Текущая ячейка с фишкой</param>
        public void FillGoalCells(Cell selectedCell, List<Cell> steps = null, List<Cell> battles = null)
        {
            if (steps == null) steps = _steps;
            if (battles == null) battles = _battles;
            var pos = selectedCell.Address;
            if (selectedCell.King) // дамка
            {
                AddKingGoal(steps, battles, pos, GoalDirection.NW);
                AddKingGoal(steps, battles, pos, GoalDirection.NE);
                AddKingGoal(steps, battles, pos, GoalDirection.SE);
                AddKingGoal(steps, battles, pos, GoalDirection.SW);
                if (battles.Count > 0)
                    steps.Clear();
            }
            else // обычная шашка
            {
                AddGoal(battles, pos, -2, -2);
                AddGoal(battles, pos, +2, -2);
                AddGoal(battles, pos, -2, +2);
                AddGoal(battles, pos, +2, +2);
                if (battles.Count > 0)
                    return;
                AddGoal(steps, pos, -1, -1);
                AddGoal(steps, pos, +1, -1);
                AddGoal(steps, pos, -1, +1);
                AddGoal(steps, pos, +1, +1);
            }
        }

        /// <summary>
        /// Добавление целевого поля для дамки
        /// </summary>
        /// <param name="goalList">Список целей, накопительный</param>
        /// <param name="pos">Адрес ячейки, вокруг которой ищется цель</param>
        /// <param name="direction">Направление поиска в "глубину"</param>
        /// <returns>true - была также найдена возможность боя</returns>
        private void AddKingGoal(List<Cell> steps, List<Cell> battles, Address pos, GoalDirection direction)
        {
            int dx, dy;
            switch (direction)
            {
                case GoalDirection.NW: dx = dy = -1; break;
                case GoalDirection.NE: dx = +1; dy = -1; break;
                case GoalDirection.SE: dx = dy = +1; break;
                case GoalDirection.SW: dx = -1; dy = +1; break;
                default: return;
            }
            var source = (Cell)_cells[pos];
            var combat = false;
            var addr = pos;
            while (true)
            {
                addr = new Address(addr.Coords.X + dx, addr.Coords.Y + dy);
                if (addr.IsEmpty()) break;
                var cell = (Cell)_cells[addr];
                if (cell.State == State.Empty)
                {
                    if (combat)
                        battles.Add((Cell)_cells[addr]);
                    else
                        steps.Add((Cell)_cells[addr]);
                }
                else if (cell.State != source.State)
                {
                    addr = new Address(addr.Coords.X + dx, addr.Coords.Y + dy);
                    if (addr.IsEmpty()) break;
                    cell = (Cell)_cells[addr];
                    if (cell.State == State.Empty)
                    {
                        if (combat) break;
                        battles.Add((Cell)_cells[addr]);
                        combat = true;
                    }
                    else
                        break;
                }
                else
                    break;
            }
        }

        /// <summary>
        /// Добавление целевого поля для шашки
        /// </summary>
        /// <param name="goalList">Список целей, накопительный</param>
        /// <param name="pos">Адрес ячейки, вокруг которой ищется цель</param>
        /// <param name="dx">Шаг поиска по горизонтали</param>
        /// <param name="dy">Шаг поиска по вертикали</param>
        private void AddGoal(List<Cell> goalList, Address pos, int dx, int dy)
        {
            var addr = new Address(pos.Coords.X + dx, pos.Coords.Y + dy);
            var check = CheckMove(pos, addr);
            if (check != MoveResult.Prohibited)
                goalList.Add((Cell)_cells[addr]);
        }
    }
}

Cell.cs
using System;

namespace Checkers
{
    /// <summary>
    /// Empty, Black, White, Prohibited
    /// </summary>
    public enum State
    {
        Prohibited = 3,
        Empty = 0,
        White = 2,
        Black = 1
    }

    /// <summary>
    /// Клетка доски
    /// </summary>
    [Serializable]
    public class Cell
    {
        /// <summary>
        /// Адрес ячейки
        /// </summary>
        public Address Address { get; set; }

        /// <summary>
        /// Состояние ячейки: Empty, Black, White, Prohibited
        /// </summary>
        public State State { get; set; }

        /// <summary>
        /// Признак "дамки"
        /// </summary>
        public bool King { get; set; }
    }
}

Game
using System;
using System.Collections.Generic;

namespace Checkers
{
    public enum Player
    {
        White,
        Black
    }

    public enum WinPlayer
    {
        None,   // игра не начата
        Game,   // игра идёт
        White,  // белые выиграли
        Black,  // чёрные выиграли
        Draw    // ничья
    }

    public enum PlayMode
    {
        Game,       // игра с компьютером
        NetGame,    // игра по сети
        SelfGame,   // игра с самим собой
        Collocation // расстановка фишек
    }

    [Serializable]
    public class Game
    {
        public List<LogItem> Log { get; set; }

        public int WhiteScore { get; set; }
        public int BlackScore { get; set; }

        public bool Direction { get; set; }

        public Player Player { get; set; }

        public WinPlayer WinPlayer { get; set; }

        public PlayMode Mode { get; set; }

        public Game()
        {
            Log = new List<LogItem>();
        }

        public void CheckWin()
        {
            WinPlayer = WhiteScore == 12
                ? WinPlayer.White
                : BlackScore == 12 
                     ? WinPlayer.Black 
                     : WinPlayer.Game;
        }

        public override string ToString()
        {
            switch (WinPlayer)
            {
                case WinPlayer.None:
                    return "Выберите тип игры...";
                case WinPlayer.Game:
                    return Direction ? "Ход чёрных..." : "Ход белых...";
                case WinPlayer.White:
                    return "Белые выиграли";
                case WinPlayer.Black:
                    return "Чёрные выиграли";
                case WinPlayer.Draw:
                    return "Ничья";
            }
            return base.ToString();
        }
    }
}

lo.cs 
using System.Collections.Generic;
using System.Drawing;

namespace Checkers
{
    public class Io
    {
        const int CellSize = 50;    // размер стороны клетки в пикселах
        const int BorderWidth = 20; // ширина бордюра в пикселах
        Board _board;
        Game _game;
        Size _topLeftSize;
        List<Cell> _hoverCells;

        public Io(Game game, Board board, Size topLeftSize)
        {
            _game = game;
            _board = board;
            _topLeftSize = topLeftSize;
            _hoverCells = new List<Cell>();
        }

        public void SetGame(Game game)
        {
            _game = game;
        }

        /// <summary>
        /// Получение расчётного размера доски
        /// </summary>
        /// <returns>Ширина и высота доски вместе с бордюром</returns>
        public Size GetDrawBoardSize()
        {
            var boardSize = _board.SideSize;
            return new Size(boardSize * CellSize + BorderWidth * 2, boardSize * CellSize + BorderWidth * 2);
        }

        /// <summary>
        /// Получение адреса клетки под курсором
        /// </summary>
        /// <param name="mouse">Координаты курсора</param>
        /// <returns>Возвращается адрес клетки</returns>
        public Address GetCellAddress(Point mouse)
        {
            var side = _game.Player == Player.Black; // переворот доски
            var boardSize = _board.SideSize;
            for (var i = 0; i < boardSize; i++)
            {
                var ix = side ? boardSize - i - 1 : i;
                for (var j = 0; j < boardSize; j++)
                {
                    var jx = side ? boardSize - j - 1 : j;
                    var rect = new Rectangle(_topLeftSize.Width + BorderWidth + jx * CellSize, 
                        _topLeftSize.Height + BorderWidth + ix * CellSize, CellSize, CellSize);
                    if (rect.Contains(mouse))
                        return new Address(j, i);
                }
            }
            return new Address();
        }

        /// <summary>
        /// Получаем прямоугольник ячейки под курсором
        /// </summary>
        /// <param name="mouse"></param>
        /// <returns></returns>
        public Rectangle GetCellRect(Point mouse)
        {
            var side = _game.Player == Player.Black; // переворот доски
            var boardSize = _board.SideSize;
            for (var i = 0; i < boardSize; i++)
            {
                var ix = side ? boardSize - i - 1 : i;
                for (var j = 0; j < boardSize; j++)
                {
                    var jx = side ? boardSize - j - 1 : j;
                    var rect = new Rectangle(_topLeftSize.Width + BorderWidth + jx * CellSize,
                        _topLeftSize.Height + BorderWidth + ix * CellSize, CellSize, CellSize);
                    if (rect.Contains(mouse))
                        return rect;
                }
            }
            return Rectangle.Empty;
        }

        /// <summary>
        /// Получение клетки по координатам под курсором
        /// </summary>
        /// <param name="mouse">Координаты курсора</param>
        /// <param name="cell">Найденная клетка доски</param>
        /// <returns>true - клетка найдена под курсором</returns>
        public bool GetCell(Point mouse, out Cell cell)
        {
            cell = null;
            return _board.GetCell(GetCellAddress(mouse), out cell);
        }

        /// <summary>
        /// Рисование доски
        /// </summary>
        /// <param name="graphics">Канва для рисования</param>
        public void DrawBoard(Graphics graphics)
        {
            var side = _game.Player == Player.Black; // переворот доски
            var fields = _board.GetFields();
            var map = _board.GetMap();
            var cellsCount = _board.SideSize;
            var boardSize = GetDrawBoardSize();
            var boardRect = new Rectangle(new Point(_topLeftSize.Width, _topLeftSize.Height), boardSize);
            using (var brush = new SolidBrush(Color.FromArgb(234, 206, 175)))
                graphics.FillRectangle(brush, boardRect);
            DrawCharBorder(graphics, boardRect, cellsCount, side);
            DrawNumberBorder(graphics, boardRect, cellsCount, side);
            // рисуем поля доски
            for (var i = 0; i < cellsCount; i++)
            {
                var ix = side ? cellsCount - i - 1 : i;
                for (var j = 0; j < cellsCount; j++)
                {
                    var jx = side ? cellsCount - j - 1 : j;
                    var rect = new Rectangle(_topLeftSize.Width + BorderWidth + jx * CellSize,
                        _topLeftSize.Height + BorderWidth + ix * CellSize, CellSize, CellSize);
                    var address = new Address(j, i);
                    var fieldState = (State)fields[address]; // цвет поля доски
                    var mapCell = (Cell)map[address];        // наличие и цвет фигур
                    using (var brush = new SolidBrush(fieldState == State.Black
                                             ? Color.FromArgb(129, 112, 94)
                                             : Color.FromArgb(233, 217, 200)))
                        graphics.FillRectangle(_hoverCells.Contains(mapCell) && !_down
                                                    ? Brushes.DarkGray
                                                    : _board.GetSteps().Contains(mapCell) ? Brushes.DarkGray
                                                              : _board.GetBattles().Contains(mapCell) ? Brushes.DarkGray : brush, rect);
                    if (mapCell != _board.Selected || !_down)
                        DrawChecker(graphics, rect, mapCell);
                }
            }
            if (_down)
                DrawChecker(graphics, _moveRect, _board.Selected, true);
        }

        /// <summary>
        /// Рисуем шашку
        /// </summary>
        /// <param name="graphics">Канва</param>
        /// <param name="rect">Прямоугольник рисования</param>
        /// <param name="mapCell">Ссылка на ячейку с фишкой</param>
        /// <param name="shadow">Тень под фишкой</param>
        private static void DrawChecker(Graphics graphics, Rectangle rect, Cell mapCell, bool shadow = false)
        {
            if (mapCell == null) return;
            if (mapCell.State == State.White || mapCell.State == State.Black)
            {
                var sizeW = CellSize - (int)(CellSize * 0.91);
                var sizeH = CellSize - (int)(CellSize * 0.91);
                rect.Inflate(-sizeW, -sizeH);
                if (shadow)
                {
                    const int shadowOffset = 6;
                    rect.Offset(shadowOffset, shadowOffset);
                    using (var brush = new SolidBrush(Color.FromArgb(128, Color.Black)))
                        graphics.FillEllipse(brush, rect);
                    rect.Offset(-shadowOffset, -shadowOffset);
                }
                using (var brush = new SolidBrush(mapCell.State == State.Black
                                     ? Color.FromArgb(10, 10, 10)
                                     : Color.FromArgb(250, 250, 250)))
                    graphics.FillEllipse(brush, rect);
                rect.Inflate(-sizeW, -sizeH);
                graphics.DrawEllipse(Pens.Gray, rect);
                if (!mapCell.King)
                {
                    rect.Inflate(-sizeW, -sizeH);
                    graphics.DrawEllipse(Pens.Gray, rect);
                }
            }
        }

        #region Рисование бордюра вокруг доски с обозначениями полей

        /// <summary>
        /// Рисование букв столбцов по обеим сторонам доски
        /// </summary>
        /// <param name="graphics">Канва для рисования</param>
        /// <param name="boardRect">Размер доски вместе с рамкой</param>
        /// <param name="cellsCount">Количество клеток по стороне</param>
        /// <param name="side">Сторона игрока (нижняя): false - белые, true - чёрные</param>
        private void DrawCharBorder(Graphics graphics, Rectangle boardRect, int cellsCount, bool side)
        {
            var chars = side ? "HGFEDCBA" : "ABCDEFGH";
            for (var j = 0; j < cellsCount; j++)
            {
                var topRect = new Rectangle(BorderWidth + j * CellSize,  _topLeftSize.Height, CellSize, BorderWidth);
                var bottomRect = new Rectangle(BorderWidth + j * CellSize, 
                                           _topLeftSize.Height + boardRect.Height - BorderWidth, CellSize, BorderWidth);
                using (var sf = new StringFormat())
                {
                    sf.Alignment = StringAlignment.Center;
                    sf.LineAlignment = StringAlignment.Center;
                    var ch = chars.ToCharArray()[j].ToString();
                    graphics.DrawString(ch, SystemFonts.CaptionFont, Brushes.Black, topRect, sf);
                    graphics.DrawString(ch, SystemFonts.CaptionFont, Brushes.Black, bottomRect, sf);
                }
            }
        }

        /// <summary>
        /// Рисование номеров строк по обеим сторонам доски
        /// </summary>
        /// <param name="graphics">Канва для рисования</param>
        /// <param name="boardRect">Размер доски вместе с рамкой</param>
        /// <param name="cellsCount">Количество клеток по стороне</param>
        /// <param name="side">Сторона игрока (нижняя): false - белые, true - чёрные</param>
        private void DrawNumberBorder(Graphics graphics, Rectangle boardRect, int cellsCount, bool side)
        {
            var chars = side ? "12345678" : "87654321";
            for (var i = 0; i < cellsCount; i++)
            {
                var topRect = new Rectangle(0, _topLeftSize.Height + BorderWidth + i * CellSize, BorderWidth, CellSize);
                var bottomRect = new Rectangle(boardRect.Width - BorderWidth, 
                                               _topLeftSize.Height + BorderWidth + i * CellSize, BorderWidth, CellSize);
                using (var sf = new StringFormat())
                {
                    sf.Alignment = StringAlignment.Center;
                    sf.LineAlignment = StringAlignment.Center;
                    var ch = chars.ToCharArray()[i].ToString();
                    graphics.DrawString(ch, SystemFonts.CaptionFont, Brushes.Black, topRect, sf);
                    graphics.DrawString(ch, SystemFonts.CaptionFont, Brushes.Black, bottomRect, sf);
                }
            }
        }

        #endregion

        bool _down;
        Point _downOffset;
        Rectangle _moveRect;

        /// <summary>
        /// Пользователь выбрал курсором ячейку или фишку
        /// </summary>
        /// <param name="location"></param>
        /// <param name="modifierKeys"></param>
        public void MouseDown(Point location)
        {
            var sourceAddress = GetCellAddress(location);
            _board.SelectSourceCell(sourceAddress);
            if (_board.Selected != null)
            {
                _down = true;
                _moveRect = GetCellRect(location);
                _moveRect.Offset(-2, -2); // "приподнимание" фишки в момент нажатия
                _downOffset = new Point(location.X - _moveRect.X, location.Y - _moveRect.Y);
            }
        }

        Cell _lastCell; // была выбрана в прошлый раз

        /// <summary>
        /// Перемещение указателя мыши
        /// </summary>
        /// <param name="location">Позиция курсора</param>
        public void MouseMove(Point location)
        {
            if (_game.WinPlayer != WinPlayer.Game) return;
            var address = GetCellAddress(location);
            Cell cell;
            // если под курсором найдена разрешённая ячейка
            if (GetCell(location, out cell) && cell.State != State.Prohibited)
            {
                if (_game.Mode == PlayMode.Game || _game.Mode == PlayMode.NetGame)
                {
                    if (_game.Player == Player.Black && !_game.Direction ||
                    _game.Player == Player.White && _game.Direction) return;
                }
                // и эта ячейка другая 
                if (cell != _lastCell)
                {
                    // если уже была выбрана другая ячейка
                    if (_lastCell != null) LeaveCell(_lastCell);
                    _lastCell = cell;   // запоминаем выбранную ячейку
                    // пытаемся выбрать эту ячейку
                    EnterCell(cell);
                }
            }
            else if (_lastCell != null)
            {
                // покидаем ячейку
                LeaveCell(_lastCell);
                _lastCell = null;
            }

            if (_down)
            {
                _moveRect.Location = new Point(location.X - _downOffset.X, location.Y - _downOffset.Y);
            }
        }

        public void MouseUp(Point location)
        {
            if (_down)
            {
                var targetAddress = GetCellAddress(location);
                Cell cell;
                // если под курсором найдена разрешённая ячейка
                if (GetCell(location, out cell) && cell != _board.Selected && cell.State != State.Prohibited)
                {
                    _board.SelectTargetCell(targetAddress);
                }
                else
                    _board.Selected = null;
                _down = false;
                _downOffset = Point.Empty;
                _moveRect = Rectangle.Empty;
            }
        }

        /// <summary>
        /// Попытка выбрать ячейку
        /// </summary>
        /// <param name="cell"></param>
        private void EnterCell(Cell cell)
        {
            _hoverCells.Clear();
            // добавляем, только если можно выбрать
            if (_board.CanCellEnter(cell))
                _hoverCells.Add(cell);
        }

        /// <summary>
        /// Действия при покидании ячейки
        /// </summary>
        /// <param name="cell"></param>
        private void LeaveCell(Cell cell)
        {
            _hoverCells.Clear();
        }
    }
}

Logltem.cs
using System;
using System.Collections.Generic;

namespace Checkers
{
    [Serializable]
    public class LogItem
    {
        private List<object> _semiSteps;

        /// <summary>
        /// Номер по порядку
        /// </summary>
        public int Number { get; set; }

        /// <summary>
        /// Ход белых
        /// </summary>
        public string White { get; set; }

        /// <summary>
        /// Ход чёрных
        /// </summary>
        public string Black { get; set; }

        /// <summary>
        /// 
        /// </summary>
        public object GetLastMap()
        {
            return _semiSteps.Count > 0 ? _semiSteps[_semiSteps.Count - 1] : null;
        }

        public IEnumerable<object> GetMapSemiSteps()
        {
            return _semiSteps;
        }

        public void AddToMap(object value)
        {
            _semiSteps.Add(value);
        }

        public LogItem()
        {
            _semiSteps = new List<object>();
        }

        /// <summary>
        /// Текстовое представления
        /// </summary>
        /// <returns></returns>
        public override string ToString()
        {
            return string.Format("{0}. {1}\t{2}", Number, White, Black);
        }
    }
}

ObjectCloner.cs
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

namespace Checkers
{
    /// <summary>
    /// Глубокое клонирование для [Serializable] объектов
    /// </summary>
    public static class ObjectCloner
    {
        public static T DeepClone<T>(this T obj) where T : class
        {
            if (obj == null)
                return null;

            var bf = new BinaryFormatter();
            using (var stream = new MemoryStream())
            {
                bf.Serialize(stream, obj);
                stream.Position = 0;
                return (T)bf.Deserialize(stream);
            }
        }
    }
}

SaverLoader.cs
using System.IO;
using System.IO.Compression;
using System.Runtime.Serialization.Formatters.Binary;

namespace Checkers
{
    public static class SaverLoader
    {
        public static Game LoadFromFile(string fileName)
        {
            using (var fs = File.OpenRead(fileName))
            using (var zip = new GZipStream(fs, CompressionMode.Decompress))
            {
                var formatter = new BinaryFormatter();
                var game = (Game)formatter.Deserialize(zip);
                return game;
            }
        }

        public static void SaveToFile(string fileName, Game game)
        {
            using (var fs = File.Create(fileName))
            using (var zip = new GZipStream(fs, CompressionMode.Compress))
            {
                var formatter = new BinaryFormatter();
                formatter.Serialize(zip, game);
            }
        }

    }
}

Дальше будет фалй Net 
IP2PService.cs
using System;
using System.ServiceModel;

namespace Checkers.Net
{
    [ServiceContract]
    public interface IP2PService
    {
        [OperationContract]
        string GetName();

        [OperationContract]
        Player GetPlayer();

        [OperationContract]
        Guid GetPlayerId();

        [OperationContract(IsOneWay = true)]
        void SendMessage(P2PData message, string from);

        [OperationContract(IsOneWay = true)]
        void SendConnect(Guid id, string from);

    }
}

NetGame.cs
using System;
using System.Collections.Generic;
using System.Net;
using System.Net.PeerToPeer;
using System.ServiceModel;
using System.Threading.Tasks;

namespace Checkers.Net
{
    public class NetGame : IDisplayMessage
    {
        private P2PService localService;
        //private string serviceUrl;
        private ServiceHost host;
        private PeerName peerName;
        private PeerNameRegistration peerNameRegistration;
        private Game _game;
        private readonly Board _board;

        public bool Started { get; set; }

        public string StartingError { get; set; }

        public bool CanRefreshPeers { get; set; }

        public List<PeerEntry> PeerList { get; set; }

        public PeerEntry Enemy { get; set; }

        public Guid Id { get; private set; }

        public string Caption
        {
            get
            {
                if (_game.Mode == PlayMode.NetGame)
                    return Enemy == null 
                        ? string.Format("Шашки - {0} ожидает противника...", Properties.Settings.Default.P2PUserName)
                        : _game.Player == Player.White 
                              ? string.Format("Шашки - {0} против {1}", Properties.Settings.Default.P2PUserName, Enemy.DisplayString)
                              : string.Format("Шашки - {0} против {1}", Enemy.DisplayString, Properties.Settings.Default.P2PUserName);

                return "Шашки";
            }
        }

        public NetGame(Game game, Board board)
        {
            PeerList = new List<PeerEntry>();
            Id = Guid.NewGuid();
            _game = game;
            _board = board;
        }

        public void SetGame(Game game)
        {
            _game = game;
        }

        public void SendNetGameStatus()
        {
            if (Started && Enemy != null)
            {
                var item = _game.Log[_game.Log.Count - 1];
                var step = string.Format("{0}", _game.Direction ? item.White : item.Black);
                SendMessage(Enemy, new P2PData(_game.Direction ? Player.Black : Player.White, Id,
                    step, _game.BlackScore, _game.WhiteScore)
                { Map = _board.ToString() });
            }
        }

        public Task RefreshPeersAsync()
        {
            var task = new Task(() => RefreshPeers());
            task.Start();
            return task;
        }

        public void RefreshPeers()
        {
            // Создание распознавателя и добавление обработчиков событий
            PeerNameResolver resolver = new PeerNameResolver();
            resolver.ResolveProgressChanged +=
                new EventHandler<ResolveProgressChangedEventArgs>(resolver_ResolveProgressChanged);
            resolver.ResolveCompleted +=
                new EventHandler<ResolveCompletedEventArgs>(resolver_ResolveCompleted);

            // Подготовка к добавлению новых пиров
            PeerList.Clear();
            CanRefreshPeers = false;

            // Преобразование незащищенных имен пиров асинхронным образом
            resolver.ResolveAsync(new PeerName("0.P2P Sample"), 1);
        }

        public event Action ResolveCompleted = delegate { };

        void resolver_ResolveCompleted(object sender, ResolveCompletedEventArgs e)
        {
            CanRefreshPeers = true;
            ResolveCompleted();
        }

        public event Action ResolveProgressChanged = delegate { };

        void resolver_ResolveProgressChanged(object sender, ResolveProgressChangedEventArgs e)
        {
            PeerNameRecord peer = e.PeerNameRecord;

            foreach (IPEndPoint ep in peer.EndPointCollection)
            {
                if (ep.Address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    try
                    {
                        string endpointUrl = string.Format("net.tcp://{0}:{1}/P2PService", ep.Address, ep.Port);
                        NetTcpBinding binding = new NetTcpBinding();
                        binding.Security.Mode = SecurityMode.None;
                        IP2PService serviceProxy = ChannelFactory<IP2PService>.CreateChannel(
                            binding, new EndpointAddress(endpointUrl));
                        PeerList.Add(
                           new PeerEntry
                           {
                               PeerName = peer.PeerName,
                               ServiceProxy = serviceProxy,
                               DisplayString = serviceProxy.GetName(),
                               State = PeerState.User,
                               Player = serviceProxy.GetPlayer(),
                               PlayerId = serviceProxy.GetPlayerId()
                           });
                        ResolveProgressChanged();
                    }
                    catch (EndpointNotFoundException)
                    {
                    }
                }
            }
        }

        public void SendConnect(PeerEntry peerEntry)
        {
            // Получение пира и прокси, для отправки сообщения
            if (peerEntry != null && peerEntry.ServiceProxy != null)
            {
                try
                {
                    peerEntry.ServiceProxy.SendConnect(Id, Properties.Settings.Default.P2PUserName);
                }
                catch (CommunicationException)
                {

                }
            }
        }

        public void SendMessage(PeerEntry peerEntry, P2PData message)
        {
            // Получение пира и прокси, для отправки сообщения
            if (peerEntry != null && peerEntry.ServiceProxy != null)
            {
                try
                {
                    peerEntry.ServiceProxy.SendMessage(message, Properties.Settings.Default.P2PUserName);
                }
                catch (CommunicationException)
                {

                }
            }
        }

        public event Action<P2PData, string> DisplayPeerMessage = delegate { };

        public void DisplayMessage(P2PData message, string from)
        {
            DisplayPeerMessage(message, from);
        }

        public void DisplayConnect(Guid id, string from)
        {
            if (Started && Enemy == null)
            {
                ResolveCompleted += _net_ResolveCompleted;
                _connectId = id;
                _connCount = 10;
                RefreshPeersAsync();
            }
        }

        private Guid _connectId;
        private int _connCount;

        private void _net_ResolveCompleted()
        {
            foreach (var peer in PeerList)
            {
                if (peer.PlayerId == _connectId)
                {
                    Enemy = peer;
                    ResolveCompleted -= _net_ResolveCompleted;
                    _game.WinPlayer = WinPlayer.Game;
                    CaptionChanged();
                    return;
                }
            }
            _connCount--;
            if (_connCount <= 0) return;
            RefreshPeersAsync();
        }

        public event Action CaptionChanged = delegate { };

        private bool Start(string port, string username, Player player, string machineName)
        {
            if (Started) return true;
            Enemy = null;
            Started = false;

            #region Взято отюда: https://professorweb.ru/my/csharp/web/level8/8_3.php

            // Конфигурирование сети 
            // Получение конфигурационной информации из app.config
            string serviceUrl = null;

            //  Получение URL-адреса службы с использованием адресаIPv4 
            //  и порта из конфигурационного файла
            foreach (IPAddress address in Dns.GetHostAddresses(Dns.GetHostName()))
            {
                if (address.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    serviceUrl = string.Format("net.tcp://{0}:{1}/P2PService", address, port);
                    break;
                }
            }

            // Выполнение проверки, не является ли адрес null
            if (serviceUrl == null)
            {
                // Отображение ошибки и завершение работы приложения
                StartingError = "Не удается определить адрес конечной точки WCF.";
                return false;
            }

            // Регистрация и запуск службы WCF
            localService = new P2PService(this, username, player, Id);

            host = new ServiceHost(localService, new Uri(serviceUrl));
            NetTcpBinding binding = new NetTcpBinding();
            binding.Security.Mode = SecurityMode.None;
            host.AddServiceEndpoint(typeof(IP2PService), binding, serviceUrl);
            try
            {
                host.Open();
            }
            catch (AddressAlreadyInUseException)
            {
                // Отображение ошибки и завершение работы приложения
                StartingError = "Не удаётся начать прослушивание, порт занят.";
                return false;
            }

            // Создание имени равноправного участника (пира)
            peerName = new PeerName("P2P Sample", PeerNameType.Unsecured);

            // Подготовка процесса регистрации имени равноправного участника в локальном облаке
            peerNameRegistration = new PeerNameRegistration(peerName, int.Parse(port))
            {
                Cloud = Cloud.AllLinkLocal
            };

            // Запуск процесса регистрации
            peerNameRegistration.Start();

            #endregion

            Started = true;
            return Started;
        }

        public Task<bool> StartAsync(string port, string username, Player player, string machineName)
        {
            var task = new Task<bool>(() => Start(port, username, player, machineName));
            task.Start();
            return task;
        }

        private void Stop()
        {
            if (!Started) return;
            Started = false;

            #region Взято отюда: https://professorweb.ru/my/csharp/web/level8/8_3.php

            // Остановка регистрации
            peerNameRegistration.Stop();

            // Остановка WCF-сервиса
            host.Close();

            #endregion
        }

        public Task StopAsync()
        {
            var task = new Task(() => Stop());
            task.Start();
            return task;
        }

        public Task RestartAsync(string port, string username, Player player, string machineName)
        {
            var task = new Task(() => 
            {
                Stop();
                Start(port, username, player, machineName);
            });
            task.Start();
            return task;

        }
    }
}

P2PData.cs
using System;
using System.Text;

namespace Checkers.Net
{
    [Serializable]
    public struct P2PData
    {
        public P2PData(Player player, Guid id, string step, int blackScore, int whiteScore)
        {
            Player = player;
            PlayerId = id;
            Step = step;
            BlackScore = blackScore;
            WhiteScore = whiteScore;
            Map = "";
        }

        public Player Player { get; set; }
        public Guid PlayerId { get; set; }
        public string Step { get; set; }
        public int BlackScore { get; set; }
        public int WhiteScore { get; set; }
        public string Map { get; set; }

        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.AppendLine("Player=" + Player);
            sb.AppendLine("PlayerId=" + PlayerId);
            sb.AppendLine("Step=" + Step);
            sb.AppendLine("BlackScore=" + BlackScore);
            sb.AppendLine("WhiteScore=" + WhiteScore);
            sb.AppendLine("Map=" + Map);
            return sb.ToString();
        }
    }
}

P2PService.cs
using System;
using System.ServiceModel;

namespace Checkers.Net
{
    public interface IDisplayMessage
    {
        void DisplayMessage(P2PData message, string from);
        void DisplayConnect(Guid id, string from);
    }

    [ServiceBehavior(InstanceContextMode = InstanceContextMode.Single)]
    public class P2PService : IP2PService
    {
        private IDisplayMessage hostReference;
        private string username;
        private Player player;
        private Guid id;

        public P2PService(IDisplayMessage hostReference, string username, Player player, Guid id)
        {
            this.hostReference = hostReference;
            this.username = username;
            this.player = player;
            this.id = id;
        }

        public string GetName()
        {
            return username;
        }

        public Player GetPlayer()
        {
            return player;
        }

        public Guid GetPlayerId()
        {
            return id;
        }

        public void SendConnect(Guid id, string from)
        {
            hostReference.DisplayConnect(id, from);
        }

        public void SendMessage(P2PData message, string from)
        {
            hostReference.DisplayMessage(message, from);
        }
    }
}

PeerEntry.cs
using System;
using System.Net.PeerToPeer;

namespace Checkers.Net
{
    public enum PeerState
    {
        Unknown,
        NotFound,
        User
    }

    public class PeerEntry
    {
        public PeerName PeerName { get; set; }
        public IP2PService ServiceProxy { get; set; }
        public string DisplayString { get; set; }
        public Player Player { get; set; }
        public PeerState State { get; set; }
        public Guid PlayerId { get; set; }

        public override string ToString()
        {
            return string.Format("{0}, играет {1}", DisplayString, Player == Player.Black ? "чёрными":"белыми");
        }
    }
}

App.config
using System;
using System.Net.PeerToPeer;

namespace Checkers.Net
{
    public enum PeerState
    {
        Unknown,
        NotFound,
        User
    }

    public class PeerEntry
    {
        public PeerName PeerName { get; set; }
        public IP2PService ServiceProxy { get; set; }
        public string DisplayString { get; set; }
        public Player Player { get; set; }
        public PeerState State { get; set; }
        public Guid PlayerId { get; set; }

        public override string ToString()
        {
            return string.Format("{0}, играет {1}", DisplayString, Player == Player.Black ? "чёрными":"белыми");
        }
    }
}

Дальше у меня идет основаня форма CheckersForm.cs
using System;
using System.Drawing;
using System.Drawing.Drawing2D;
using System.Threading;
using System.Windows.Forms;
using Checkers.Net;

namespace Checkers
{
    public partial class CheckersForm : Form
    {
        private Io _io;
        private Board _board;
        private Game _game;
        private NetGame _net;

        public CheckersForm()
        {
            InitializeComponent();
            mainStatus.SizingGrip = false;
            
            DoubleBuffered = true;
            _game = new Game() { Mode = PlayMode.SelfGame };
            _board = new Board(_game);
            _board.UpdateStatus += () => UpdateStatus();
            _board.ShowError += _board_ShowError;
            _board.AskQuestion += _board_AskQuestion;
            _board.ActivePlayerChanged += _board_ActivePlayerChanged;
            _board.CheckerMoved += _board_CheckerMoved;
            _net = new NetGame(_game, _board);
            _net.DisplayPeerMessage += _net_DisplayPeerMessage;
            _net.CaptionChanged += _net_CaptionChanged;
           _io = new Io(_game, _board, new Size(0, mainMenu.Height + mainTools.Height));
        }

        private void _net_CaptionChanged()
        {
            UpdateCaptionText(_net.Caption);
        }

        private bool _board_AskQuestion(string text, string caption)
        {
            return MessageBox.Show(this, text, caption, MessageBoxButtons.YesNo,
                MessageBoxIcon.Question, MessageBoxDefaultButton.Button2) == DialogResult.Yes;
        }

        private void _board_ShowError(string text, string caption)
        {
            //var status = string.Format(_game.Direction
            //                            ? "Ход чёрных ({0})..." 
            //                            : "Ход белых ({0})...", text.ToLower().TrimEnd('!'));
            UpdateStatusText(_game.ToString());
            //MessageBox.Show(this, text, caption, MessageBoxButtons.OK, MessageBoxIcon.Error);
        }

        private void _board_CheckerMoved(bool direction, Address startPos, Address endPos, MoveResult moveResult, int stepCount)
        {
            UpdateLog(direction, startPos, endPos, moveResult, stepCount);
            tsmiSaveGame.Enabled = tsbSaveGame.Enabled = true;
        }

        private void UpdateLog(bool direction, Address startPos, Address endPos, MoveResult moveResult, int stepCount)
        {
            var result = string.Format("{0}{1}{2}",
                    startPos, moveResult == MoveResult.SuccessfullCombat ? ":" : "-", endPos);
            if (!direction)
            {
                // ходят "белые"
                if (stepCount == 1) // первый ход (из, возможно, серии ходов)
                {
                    var item = new LogItem() { Number = _game.Log.Count + 1, White = result };
                    item.AddToMap(_board.GetMap().DeepClone());
                    _game.Log.Add(item);
                    lvLog.VirtualListSize = _game.Log.Count;
                    var lvi = lvLog.Items[lvLog.Items.Count - 1];
                    lvLog.FocusedItem = lvi;
                    lvi.EnsureVisible();
                    lvLog.Invalidate();
                }
                else
                {
                    var item = _game.Log[_game.Log.Count - 1];
                    item.White += ":" + endPos;
                    item.AddToMap(_board.GetMap().DeepClone());
                    lvLog.Invalidate();
                }
            }
            else
            {
                // ходят "чёрные"
                var item = _game.Log[_game.Log.Count - 1];
                if (stepCount == 1) // первый ход (из, возможно, серии ходов)
                    item.Black = result;
                else
                    item.Black += ":" + endPos;
                item.AddToMap(_board.GetMap().DeepClone());
                lvLog.Invalidate();
            }
        }

        private void _board_ActivePlayerChanged()
        {
            UpdateStatus();
            _net.SendNetGameStatus();
        }

        private void _net_DisplayPeerMessage(P2PData message, string from)
        {
            // Показать полученное сообщение (вызывается из службы WCF)
            _board.SetMap(message.Map);
            var method = new MethodInvoker(() =>
            {
                Invalidate();
                _game.Direction = message.Player == Player.Black;
                _game.BlackScore = message.BlackScore;
                _game.WhiteScore = message.WhiteScore;
                UpdateStatusText(message.Step);
                UpdateStatus();
                if (message.Player == Player.Black)
                {
                    var item = new LogItem() { Number = _game.Log.Count + 1, White = message.Step };
                    item.AddToMap(_board.GetMap().DeepClone());
                    _game.Log.Add(item);
                    lvLog.VirtualListSize = _game.Log.Count;
                    var lvi = lvLog.Items[lvLog.Items.Count - 1];
                    lvLog.FocusedItem = lvi;
                    lvi.EnsureVisible();
                    lvLog.Invalidate();
                }
                else
                {
                    var item = _game.Log[_game.Log.Count - 1];
                    item.Black = message.Step;
                    item.AddToMap(_board.GetMap().DeepClone());
                    lvLog.Invalidate();
                }
            });
            if (InvokeRequired)
                BeginInvoke(method);
            else
                method();

        }

        private void CheckersForm_Load(object sender, EventArgs e)
        {
            // Конфигурирование игры
            _board.ResetMap();
            var size = _io.GetDrawBoardSize();
            size.Width += panelLog.Width;
            size.Height += mainMenu.Height + mainTools.Height + mainStatus.Height;
            ClientSize = size;
            UpdateStatus();
            CenterToScreen();
        }

        private void UpdateStatus()
        {
            lbWhiteScore.Text = string.Format("Белые: {0}", _game.WhiteScore);
            lbBlackScore.Text = string.Format("Чёрные: {0}", _game.BlackScore);
            UpdateCaptionText(_net.Caption);
            UpdateStatusText(_game.ToString());
        }

        private void UpdateStatusText(string text)
        {
            var method = new MethodInvoker(() =>
            {
                status.Text = text;
                mainStatus.Refresh();
            });
            if (InvokeRequired)
                BeginInvoke(method);
            else
                method();
        }

        private void UpdateCaptionText(string text)
        {
            var method = new MethodInvoker(() =>
            {
                Text = text;
            });
            if (InvokeRequired)
                BeginInvoke(method);
            else
                method();
        }

        private void CheckersForm_FormClosed(object sender, FormClosedEventArgs e)
        {
            
        }

        private void CheckersForm_Paint(object sender, PaintEventArgs e)
        {
            var graphics = e.Graphics;
            graphics.SmoothingMode = SmoothingMode.HighQuality;
            graphics.PixelOffsetMode = PixelOffsetMode.HighQuality;
            // рисуем доску с шашками
            _io.DrawBoard(graphics);
        }

        private void CheckersForm_MouseDown(object sender, MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
            {
                var n = lvLog.SelectedIndices.Count > 0 ? lvLog.SelectedIndices[0] : -1;
                if (n < 0 || n == _game.Log.Count - 1)
                {
                    _io.MouseDown(e.Location);
                    Invalidate();
                }
                else
                    if (_board_AskQuestion("Продолжить игру?", "Шашки"))
                {
                    var item = lvLog.Items[_game.Log.Count - 1];
                    item.Selected = true;
                }
            }
        }

        private void CheckersForm_MouseMove(object sender, MouseEventArgs e)
        {
            _io.MouseMove(e.Location);
            Invalidate();
        }

        private void CheckersForm_MouseUp(object sender, MouseEventArgs e)
        {
            _io.MouseUp(e.Location);
            Invalidate();
        }

        private void tsmiExit_Click(object sender, EventArgs e)
        {
            Close();
        }

        /// <summary>
        /// Новая игра (сброс доски)
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void tsmiNewGame_Click(object sender, EventArgs e)
        {
            _game.WinPlayer = WinPlayer.None;
            _board.ResetMap();
            Invalidate();
            _game.Log.Clear();
            _game.WhiteScore = 0;
            _game.BlackScore = 0;
            lvLog.VirtualListSize = _game.Log.Count;
            lvLog.Invalidate();
            lbWhiteScore.Text = string.Format("Белые: {0}", _game.WhiteScore);
            lbBlackScore.Text = string.Format("Чёрные: {0}", _game.BlackScore);
            UpdateStatusText(_game.ToString());
        }

        private void lvLog_RetrieveVirtualItem(object sender, RetrieveVirtualItemEventArgs e)
        {
            e.Item = new ListViewItem();
            var item = _game.Log[e.ItemIndex];
            e.Item.Text = item.Number.ToString();
            e.Item.SubItems.Add(item.White);
            e.Item.SubItems.Add(item.Black);
        }

        private void lvLog_SelectedIndexChanged(object sender, EventArgs e)
        {
            if (lvLog.SelectedIndices.Count == 0) return;
            var n = lvLog.SelectedIndices[0];
            _board.Selected = null;

            var semiSteps = _game.Log[n].GetMapSemiSteps();
            foreach (var item in semiSteps)
            {
                var map = item.DeepClone();
                _board.SetMap(map);
                Refresh();
                Thread.Sleep(200);
            }

            if (n == _game.Log.Count - 1)
            {
                lvLog.SelectedIndices.Clear();
                UpdateStatus();
            }
            else
                UpdateStatusText(string.Format("Положение фигур после {0}-го хода.", n + 1));
        }

        private void tsmiTunings_Click(object sender, EventArgs e)
        {
            //
        }

        private void tsmiGameMode_Click(object sender, EventArgs e)
        {
            _game.Mode = PlayMode.Game; // игра
            panelLog.Visible = true;
            UpdateStatus();
            Invalidate();
        }

        private void tsmiCollocationMode_Click(object sender, EventArgs e)
        {
            _game.Mode = PlayMode.Collocation; // расстановка
            panelLog.Visible = false;
            UpdateStatusText("Режим расстановки шашек");
            Invalidate();
        }

        private void tsmiSaveGame_Click(object sender, EventArgs e)
        {
            SaveGame();
        }

        private void SaveGame()
        {
            if (string.IsNullOrWhiteSpace(saveGameDialog.FileName))
            {
                if (saveGameDialog.ShowDialog(this) == DialogResult.OK)
                    SaverLoader.SaveToFile(saveGameDialog.FileName, _game);
            }
            else
                SaverLoader.SaveToFile(saveGameDialog.FileName, _game);
            tsmiSaveGame.Enabled = tsbSaveGame.Enabled = false;
        }

        private void tsmiOpenGame_Click(object sender, EventArgs e)
        {
            if (openGameDialog.ShowDialog(this) == DialogResult.OK)
            {
                saveGameDialog.FileName = openGameDialog.FileName;
                _game = SaverLoader.LoadFromFile(openGameDialog.FileName);
                _board.SetGame(_game);
                _io.SetGame(_game);
                _net.SetGame(_game);
                Invalidate();
                UpdateStatus();
                lvLog.VirtualListSize = _game.Log.Count;
                lvLog.Invalidate();
            }
        }

        private void CheckersForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            if (tsmiSaveGame.Enabled)
            {
                if (MessageBox.Show(this, "Желаете сохранить игру перед выходом?", "Выход", 
                    MessageBoxButtons.YesNo, MessageBoxIcon.Question, MessageBoxDefaultButton.Button2) == DialogResult.Yes)
                {
                    SaveGame();
                }
            }
            NetStop();
        }

        private async void NetStop()
        {
            await _net.StopAsync();
        }

        private async void NetRestart()
        {
            await _net.RestartAsync(Properties.Settings.Default.P2PPort,
                       Properties.Settings.Default.P2PUserName, _game.Player,
                       Environment.MachineName);
        }

        private void tsmiTools_DropDownOpening(object sender, EventArgs e)
        {
            tsmiSelfGame.Checked = _game.WinPlayer == WinPlayer.Game && _game.Mode == PlayMode.SelfGame;
            tsmiAutoGame.Checked = _game.WinPlayer == WinPlayer.Game && _game.Mode == PlayMode.Game;
            tsmiNetGame.Checked = _game.WinPlayer == WinPlayer.Game && _game.Mode == PlayMode.NetGame;
            tsmiSelfGame.Enabled = tsmiAutoGame.Enabled = tsmiNetGame.Enabled = _game.WinPlayer != WinPlayer.Game;
        }

        private void tsmiSelfGame_Click(object sender, EventArgs e)
        {
            var last = _game.Mode;
            _game.Mode = PlayMode.SelfGame;
            if (last == PlayMode.NetGame)
                NetStop();
            _game.WinPlayer = WinPlayer.Game;
            UpdateStatus();
        }

        private void tsmiAutoGame_Click(object sender, EventArgs e)
        {
            var last = _game.Mode;
            _game.Mode = PlayMode.Game;
            if (last == PlayMode.NetGame)
                NetStop();
            _game.WinPlayer = WinPlayer.Game;
            UpdateStatus();
        }

        private void tsmiNetGame_Click(object sender, EventArgs e)
        {
            _game.WinPlayer = WinPlayer.None;
            _game.Mode = PlayMode.NetGame;
            GameTuning();
            UpdateStatus();
        }

        private void GameTuning()
        {
            var frm = new SelectNetEnemy(this, _net, _game);
            if (frm.ShowDialog(this) == DialogResult.OK)
            {
                if (_net.Started && frm.Selected != null)
                {
                    // Получение пира и прокси, для отправки сообщения
                    if (frm.Selected.State == PeerState.User)
                    {
                        _net.Enemy = frm.Selected;
                        _net.SendConnect(_net.Enemy);
                        _game.Player = frm.Selected.Player == Player.White 
                            ? Player.Black 
                            : frm.Selected.Player == Player.Black 
                                 ? Player.White 
                                 : Player.Black;
                        _game.Mode = PlayMode.NetGame;
                        _game.WinPlayer = WinPlayer.Game;
                    }
                    UpdateCaptionText(_net.Caption);
                }
            }
            else
                NetStop();
        }

        private void tsmiCreateSelfNetGame_Click(object sender, EventArgs e)
        {
            var frm = new CreateNetGame(this, _net, _game);
            if (frm.ShowDialog(this) == DialogResult.OK)
            {
                _game.WinPlayer = WinPlayer.None;
                _game.Player = frm.GetPlayer();
                _game.Mode = PlayMode.NetGame;
                Invalidate();
                UpdateCaptionText(_net.Caption);
                NetRestart();
            }
            else
                NetStop();
        }

        private void tsmiGame_DropDownOpening(object sender, EventArgs e)
        {
            tsmiOpenGame.Enabled = _game.WinPlayer != WinPlayer.Game;
        }
    }
}

ClassDiagram1.cd
<?xml version="1.0" encoding="utf-8"?>
<ClassDiagram MajorVersion="1" MinorVersion="1">
  <Class Name="Checkers.Board">
    <Position X="0.5" Y="0.5" Width="1.75" />
    <Compartments>
      <Compartment Name="Fields" Collapsed="true" />
    </Compartments>
    <TypeIdentifier>
      <HashCode>wBgAoAAEgIAEAAIFgASEBiEAAAAQigMAxAAAAVIAAAc=</HashCode>
      <FileName>Core\Board.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="Checkers.Cell">
    <Position X="4.5" Y="0.5" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAgAAAAAAAAAAAAAAAAAAACAAAABAAAAAA=</HashCode>
      <FileName>Core\Cell.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="Checkers.CheckersForm">
    <Position X="8" Y="0.5" Width="3" />
    <Compartments>
      <Compartment Name="Fields" Collapsed="true" />
    </Compartments>
    <TypeIdentifier>
      <HashCode>UB5iEBkEAWQYwFCiECjOgABDkCyIFFqoHSgAFFABgiY=</HashCode>
      <FileName>CheckersForm.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="Checkers.Game">
    <Position X="6.25" Y="0.5" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAIAAABAAACAAIAAAAAgAAAAAAAAAAQAQACA=</HashCode>
      <FileName>Core\Game.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="Checkers.Io">
    <Position X="2.5" Y="3.5" Width="1.75" />
    <Compartments>
      <Compartment Name="Fields" Collapsed="true" />
    </Compartments>
    <TypeIdentifier>
      <HashCode>ygAAABAACAAAAEAAEACAAEAAAGJAEAIHAoAACACAAAQ=</HashCode>
      <FileName>Core\Io.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="Checkers.LogItem">
    <Position X="4.5" Y="2.5" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAEAAAAAAAAAAgEAEAAAAAABAAAAAAAgEAABAAAAAA=</HashCode>
      <FileName>Core\LogItem.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="Checkers.ObjectCloner">
    <Position X="4.5" Y="8" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>Core\ObjectCloner.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="Checkers.Program" Collapsed="true">
    <Position X="11.25" Y="0.5" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAA=</HashCode>
      <FileName>Program.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="Checkers.SaverLoader">
    <Position X="4.5" Y="6.5" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAA=</HashCode>
      <FileName>Core\SaverLoader.cs</FileName>
    </TypeIdentifier>
  </Class>
  <Class Name="Checkers.Properties.Resources" Collapsed="true">
    <Position X="11.25" Y="2.25" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAAAAAABEAAAAQAAAAAAAAAAAAAAAIA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Checkers.Properties.Settings" Collapsed="true">
    <Position X="11.25" Y="1.25" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAAAAAAAAQAIAACAAABAAAAAAAAAAAAAAA=</HashCode>
    </TypeIdentifier>
  </Class>
  <Class Name="Checkers.Net.NetGame">
    <Position X="13" Y="0.5" Width="2" />
    <TypeIdentifier>
      <HashCode>ABASlgAAACAAAAADECiAoAIAgAIFAAAQKQg0AAACAAQ=</HashCode>
      <FileName>Net\NetGame.cs</FileName>
    </TypeIdentifier>
    <Lollipop Position="0.2" />
  </Class>
  <Struct Name="Checkers.Address">
    <Position X="2.75" Y="0.5" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AABAAAAAQAAAAAAEAABAAAAAAAAAAgAAQAAAAAAAAAA=</HashCode>
      <FileName>Core\Address.cs</FileName>
    </TypeIdentifier>
  </Struct>
  <Enum Name="Checkers.MoveResult">
    <Position X="11.25" Y="6.5" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAQAAAAAAAAABAAAAAAAAAAAAAAAAEAAAAAAAAA=</HashCode>
      <FileName>Core\Board.cs</FileName>
    </TypeIdentifier>
  </Enum>
  <Enum Name="Checkers.PlayMode">
    <Position X="11.25" Y="3" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAIAAAAAAAAAAAgAABAgAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>Core\Board.cs</FileName>
    </TypeIdentifier>
  </Enum>
  <Enum Name="Checkers.GoalDirection">
    <Position X="6.25" Y="3.25" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAAAAAAAAAACEAAAAAAAAAAAQgAAAAAAAAAAhCIAAA=</HashCode>
      <FileName>Core\Board.cs</FileName>
    </TypeIdentifier>
  </Enum>
  <Enum Name="Checkers.State">
    <Position X="6.25" Y="5.5" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAEAAAAAAAAAAAABAIAAAAABAAAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>Core\Cell.cs</FileName>
    </TypeIdentifier>
  </Enum>
  <Enum Name="Checkers.Player">
    <Position X="11.25" Y="4.75" Width="1.5" />
    <TypeIdentifier>
      <HashCode>AAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAA=</HashCode>
      <FileName>Core\Game.cs</FileName>
    </TypeIdentifier>
  </Enum>
  <Font Name="Segoe UI" Size="9" />
</ClassDiagram

Дальше форма создание CreateNetGames/cs
using Checkers.Net;
using System;
using System.Windows.Forms;

namespace Checkers
{
    public partial class CreateNetGame : Form
    {
        private NetGame _net;
        private Game _game;

        public CreateNetGame(Form form, NetGame net, Game game)
        {
            InitializeComponent();
            _net = net;
            _game = game;
            rbBlack.Checked = game.Player == Player.Black;
            rbWhite.Checked = game.Player == Player.White;
        }

        private void CreateNetGame_Load(object sender, EventArgs e)
        {
            NetStart();
        }

        private async void NetStart()
        {
            await _net.StartAsync(Properties.Settings.Default.P2PPort,
                       Properties.Settings.Default.P2PUserName, _game.Player,
                       Environment.MachineName);
        }

        public Player GetPlayer()
        {
            return rbBlack.Checked ? Player.Black : Player.White;
        }
    }

}

Program.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Checkers
{
    static class Program
    {
        /// <summary>
        /// Главная точка входа для приложения.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new CheckersForm());
        }
    }
}

Дальше поиск противника SelectNetEnemy.cs
using Checkers.Net;
using System;
using System.Windows.Forms;

namespace Checkers
{
    public partial class SelectNetEnemy : Form
    {
        private Form _form;
        private Game _game;
        private NetGame _net;

        public PeerEntry Selected
        {
            get
            {
                return lbPeerList.SelectedIndex >= 0 ? lbPeerList.SelectedItem as PeerEntry : null;
            }
        }

        public SelectNetEnemy(Form form, NetGame net, Game game)
        {
            InitializeComponent();
            _form = form;
            _game = game;
            _net = net;
            _net.ResolveProgressChanged += _net_ResolveProgressChanged;
            _net.ResolveCompleted += _net_ResolveCompleted;
        }

        private async void NetStart()
        {
            await _net.StartAsync(Properties.Settings.Default.P2PPort,
                       Properties.Settings.Default.P2PUserName, _game.Player,
                       Environment.MachineName);
            LoadPeers();
        }

        private void _net_ResolveCompleted()
        {
            UpdatePeerList();
            // Повторно включаем кнопку "обновить"
            var method = new MethodInvoker(() =>
            {
                btnRefreshPeers.Enabled = _net.CanRefreshPeers;
            });
            if (InvokeRequired)
                BeginInvoke(method);
            else
                method();
        }

        private void _net_ResolveProgressChanged()
        {
            UpdatePeerList();
        }

        private void UpdatePeerList()
        {
            var method = new MethodInvoker(() =>
            {
                lbPeerList.Items.Clear();
                foreach (var item in _net.PeerList.ToArray())
                {
                    if (item.State == PeerState.User)
                        lbPeerList.Items.Add(item);
                }
                lbPeerList.Invalidate();
            });
            if (InvokeRequired)
                BeginInvoke(method);
            else
                method();
        }

        private async void LoadPeers()
        {
            if (_net.Started)
            {
                btnRefreshPeers.Enabled = false;
                lbPeerList.Items.Clear();
                await _net.RefreshPeersAsync();
            }
        }

        private void SelectNetEnemy_Load(object sender, EventArgs e)
        {
            NetStart();
        }

        private void btnRefreshPeers_Click(object sender, EventArgs e)
        {
            LoadPeers();
        }

        private void SelectNetEnemy_FormClosing(object sender, FormClosingEventArgs e)
        {
            _net.ResolveProgressChanged -= _net_ResolveProgressChanged;
            _net.ResolveCompleted -= _net_ResolveCompleted;
        }

        private void lbPeerList_SelectedIndexChanged(object sender, EventArgs e)
        {
            btnSelect.Enabled = _net.Started && Selected != null && Selected.State == PeerState.User;
        }

    }
}


